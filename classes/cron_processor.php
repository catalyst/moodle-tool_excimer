<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

namespace tool_excimer;

use tool_excimer\script_metadata;

/**
 * Class for processing cron and adhoc tasks.
 *
 * The main feature is that each task is profiled separately.
 *
 * @package   tool_excimer
 * @author    Jason den Dulk <jasondendulk@catalyst-au.net>
 * @copyright 2022, Catalyst IT
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class cron_processor implements processor {

    /**
     * @var float $sampletime Timestamp updated after processing each sample.
     */
    public $sampletime;

    /**
     * @var sample_set $currenttask A sample set recorded while processing a task.
     */
    public $currenttask = null;

    /**
     * Initialises the processor
     *
     * @param manager $manager The profiler manager object
     */
    public function init(manager $manager) {
        $this->sampletime = $manager->get_starttime();

        $manager->get_timer()->setCallback(function () use ($manager) {
            $this->on_interval($manager);
        });

        \core_shutdown_manager::register_function(
            function () use ($manager) {
                $manager->get_timer()->stop();
                $manager->get_profiler()->stop();
                $this->on_interval($manager);
                if ($this->currenttask) {
                    $this->process($manager, microtime(true));
                }
            }
        );
    }

    /**
     * Gets the minimum duration required for a profile to be saved, as seconds.
     *
     * @return float
     * @throws \dml_exception
     */
    public function get_min_duration(): float {
        return (float) get_config('tool_excimer', 'task_min_duration');
    }

    /**
     * Examines a sample generated by the profiler.
     *
     * The logic represents the following:
     *
     * If a sample is the first of a task, we create a task_samples instance, and add the sample.
     * As long as subsequent samples are in the same task, we keep adding them to task_samples.
     * When we get to a sample that is not in the same task, we process the task_samples and reset it.
     *
     * We then check for a new task with the current sample.
     *
     * @param manager $manager
     */
    public function on_interval(manager $manager) {
        $profiler = $manager->get_profiler();
        $log = $profiler->flush();
        foreach ($log as $sample) {
            $taskname = $this->findtaskname($sample);
            $sampletime = $manager->get_starttime() + $sample->getTimestamp();

            if ($this->currenttask && ($this->currenttask->name != $taskname)) {
                $this->process($manager, $this->sampletime);
                $this->currenttask = null;
            }

            if ($taskname && ($this->currenttask == null)) {
                $this->currenttask = new sample_set($taskname, $this->sampletime, script_metadata::get_sample_limit());
            }

            if ($this->currenttask) {
                $this->currenttask->add_sample($sample);
            }

            // Instances of task_sample are always created with the previous sample's timestamp.
            // So it needs to be saved each loop.
            $this->sampletime = $sampletime;
        }
    }

    /**
     * Finds the name of the task being sampled, or null if not in a task.
     *
     * @param \ExcimerLogEntry $sample
     * @return string|null
     */
    public function findtaskname(\ExcimerLogEntry $sample): ?string {
        $trace = array_reverse($sample->getTrace());
        $length = count($trace);
        for ($i = 0; $i < $length; ++$i) {
            $fnname = $trace[$i]['function'] ?? null;
            if ($fnname == 'cron_run_inner_scheduled_task' || $fnname == 'cron_run_inner_adhoc_task') {
                if ($i + 1 < $length) {
                    if ('execute' == ($trace[$i + 1]['function'] ?? null)) {
                        return $trace[$i + 1]['class'];
                    }
                }
            }
        }
        return null;
    }

    /**
     * Processes stored samples to create a profile (if eligible).
     *
     * @param manager $manager
     * @param float $finishtime
     * @throws \coding_exception
     * @throws \dml_exception
     */
    public function process(manager $manager, float $finishtime): void {
        $reasonstack = 0;
        $duration = $finishtime - $this->currenttask->starttime;

        if (property_exists($this, 'currenttask') && $this->currenttask
                && $this->currenttask->get_stack_depth() > script_metadata::get_stack_limit()) {
            $reasonstack = profile::REASON_STACK;
        }
        $profile = new profile();
        $profile->add_env($this->currenttask->name);
        $profile->set('created', (int) $this->currenttask->starttime);
        $profile->set('duration', $duration);
        $reasons = $manager->get_reasons($profile) + $reasonstack;
        if ($reasons !== profile::REASON_NONE) {
            $profile->set('reason', $reasons);
            $profile->set('finished', (int) $finishtime);
            $profile->set('flamedatad3', flamed3_node::from_excimer_log_entries($this->currenttask->samples));
            $profile->save_record();
        }
    }
}
