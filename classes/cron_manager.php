<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

namespace tool_excimer;

defined('MOODLE_INTERNAL') || die();

/**
 * Manages the profiling of cron runs.
 *
 * @package   tool_excimer
 * @author    Jason den Dulk <jasondendulk@catalyst-au.net>
 * @copyright 2021, Catalyst IT
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class cron_manager {
    static public $sampletime;
    static public $currenttask;

    /**
     * Sets callbacks to handle cron profiling.
     *
     * @param \ExcimerProfiler $profiler
     * @param \ExcimerTimer $timer
     * @param float $started
     * @throws \dml_exception
     */
    public static function set_callbacks(\ExcimerProfiler $profiler, \ExcimerTimer $timer): void {
        $timer->setCallback(function() use ($profiler) {
            cron_manager::on_interval($profiler);
        });

        \core_shutdown_manager::register_function(
            function() use ($profiler, $timer) {
                $timer->stop();
                $profiler->stop();
                if (self::$currenttask) {
                    self::$currenttask->process(microtime(true));
                }
            }
        );
    }

    /**
     * Examines a sample generated by the profiler.
     *
     * The logic represents the following:
     *
     * If a sample is the first of a task, we create a task_samples instance, and add the sample.
     * As long as subsequent samples are in the same task, we keep adding them to task_samples.
     * When we get to a sample that is not in the same task, we process the task_samples and reset it.
     *
     * We then check for a new task with the current sample.
     *
     * @param \ExcimerProfiler $profiler
     */
    public static function on_interval(\ExcimerProfiler $profiler): void {
        $log = $profiler->flush();

        $log->rewind();
        if (!$log->valid()) {
            debugging('on_interval called with no profile');
            return;
        }
        $sample = $log->current();
        $log->next();
        if ($log->valid()) {
            debugging('extra profile sample found in on_interval');
        }

        $taskname = self::findtaskname($sample);
        $currenttime = microtime(true);

        if (self::$currenttask && (self::$currenttask->name != $taskname)) {
            self::$currenttask->process($currenttime);
            self::$currenttask = null;
        }

        if ($taskname && (self::$currenttask == null)) {
            self::$currenttask = new task_samples($taskname, self::$sampletime);
        }

        if (self::$currenttask) {
            self::$currenttask->add_sample($sample);
        }

        self::$sampletime = $currenttime;
    }

    /**
     * Finds the name of the task being sampled, or null if not in a task.
     *
     * @param \ExcimerLogEntry $sample
     * @return string|null
     */
    public static function findtaskname(\ExcimerLogEntry $sample): ?string {
        $trace = array_reverse($sample->getTrace());
        $length = count($trace);
        for ($i = 0; $i < $length; ++$i) {
            $fnname = $trace[$i]['function'] ?? null;
            if ($fnname == 'cron_run_inner_scheduled_task' || $fnname == 'cron_run_inner_adhoc_task') {
                if ($i + 1 < $length) {
                    if ('execute' == ($trace[$i + 1]['function'] ?? null)) {
                        return $trace[$i + 1]['class'];
                    }
                }
            }
        }
        return null;
    }
}

